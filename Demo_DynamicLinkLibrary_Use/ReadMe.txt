
版本说明：
v1版本   支持几乎完整功能的动态链接库技术实现。
具体有以下特性的支持：
1.支持DLL中含有自己定义的静态变量
2.支持Host指针方式读写DLL中的静态变量
3.支持DLL调用Host中的函数
4.支持DLL指针方式读写Host中的静态变量
5.DLL支持加载域和运行域的ROPI和RWPI
6.DLL支持函数可重入机制



技术实现的基本原理：

1.DLL中定义的静态变量，初始值存储在加载域中，但分配空间的责任要交给Host，也就是说。由宿主程序从RAM中分配静态变量的存储空间给DLL的静态变量s。加载过程由动态链接库加载器完成。加载变量运行域的同时，就把DLL中静态变量的初始值赋值过去了。
2.Host调用DLL中的函数，可以间接的访问到DLL中的静态变量，但这样效率太低。为解决这个问题，Host需要“直接”访问DLL中的静态变量，但在加载静态区的时候，Host才知道具体的地址，在Host编译时是不知道的，除非绑死RAM地址！但绑死RAM地址会遇到一些问题，且不方便。所以只能通过指针的方式，而不可能真正直接的访问静态变量，这样静态区地址可以做到每次不一样。加载器在加载完RW后，要通过设置R9寄存器来完成静态变量地址重定位，这是RWPI的关键步骤。而ROPI却不需要这样的步骤。
3.DLL调用Host中函数的方法，在DLL的中事先定义函数指针，在加载器加载DLL中的静态变量区时，将Host中的函数地址传入，写入DLL的函数指针中，之后就可以调用了。
4.DLL读写Host中的静态变量，思路和上面的2大致一样，也要在DLL中事先定义好变量指针，在加载器加载时，将地址传入赋值，之后就可以读写了。
5.DLL支持加载域和运行域的ROPI和RWPI，这样能最大程度上灵活自由的放置DLL的代码和数据到不同的地方，而不用担心受到限制。
6.这里说的可重入机制，不是指临界区的那种不可重入的性质，而是指多个线程都需要访问这个DLL，但又希望每个线程有自己的实体，更细致的来说也就是，各自访问的DLL静态变量值是独立的，不受其他线程影响。解决方法是，各个线程各自分配独立的静态区，各自用各自的R9重定位静态变量区。就像UCOS2中由用户定义数组，OS使用数组作为线程调度的栈空间。RO可共享，也可独立加载到自己的RAM中


注意：
1.如果DLL中的函数需要的临界区加解锁中函数是由宿主程序提供的，如果不能在DLL中定义加解锁，请使用第3特性完成该功能！在DLL中调用Host提供的加解锁函数！
2.暂时我还没有试过DLL中使用未初始化的静态变量的情况，也就是说DLL中没有ZI段。如果可以，请将未初始化的静态变量初始化成默认零类型值，不要有ZI段。
3.暂时没试过DLL生成ARM Code的情况，所以目前v1版本用在ARMv7-M版本以下的CPU上，可能会有问题。请尽量设置DLL工程，让编译器编译成Thumb Code。

DLL工程相关设置:
1.C/C++页，要勾选ROPI和RWPI。可以的话也请勾选ELF项，这样map文件中某些信息会更细致的展开。
2.ASM页，要勾选ROPI和RWPI
3.Linker页，由于DLL没有自己main，且运行域的排列也要调整，用-ro-base和-rw-base，几乎不可能完成灵活、自由的设置，请使用分散加载脚本，可参考本工程中的sct文件。




关联量的手动设置：
assmbly文件中：
1.DLL的长度，请查看map文件，获取DLL的长度，或者直接查看生成的bin文件大小，转换成16进制数，写入assmbly.s的第一个DCD中
2.请自行维护自己的DLL版本，宿主程序兼容DLL的支持，就依靠这个版本号。填入第2个DCD
3.静态变量在DLL中的偏移地址，请查看map文件中，首个RW section的地址，然后减掉DLL的基地址，填入第3个DCD
4.将需要引出的DLL函数，函数名填入 第1个DCB
5.由于地址对齐问题，如果DCD的地址不是4的整数倍，汇编器会自动填0，保证DCD对齐到4倍地址值。
  而我这里的Name2Addr没有设计好，需要手工填写这些填0的地方，请使用DCB指令，带“%”填入
6.在map文件中查看对应的函数地址，同上，减去DLL基地址得到偏移地址，但因ARMv7-M的指令集要求，Thmub模式的函数地址，在写入PC时最后一位是1
  所以这里手动加1，不加1可能进入硬件错误。


其他函数引出都如此添加。
重复 4、5、6


动态库文件：
1.在Host中被DLL访问的函数，请先定义对应函数类型的函数指针。具体参考源码
2.在Host中被DLL访问的变量，请先定义对应类型的指针变量。具体参考源码


DLL工程中的sct文件
1.用汇编文件的方式，强制要求把含有函数名和地址的映射表排到文件头，把DLL的长度，版本，以及静态变量区的偏移量都按事先定义好的顺序存放到这里
2.将RO段的加载域紧跟其后，没有特别的要求。另外，工程编译时警告没有入口点，但DLL本身并不需要入口点。有的朋友熟悉用法，可自行添加命令，少掉这个警告。但我自己简单的试了下，在编译命令中手工指定某个函数为入口点，虽然少了两个警告，但其他的函数却被优化掉不编译，一时想不起来怎么要求编译器不优化掉没被调用的函数。所以只好还原成不带入口，只好先让编译器警告没有入口点了。
3.有个警告说最后一行不是换行的，请不要搭理它！



宿主工程中的加载器代码：
1.请注意R9寄存器的使用，也就是__global_reg(6)。ROPI和RWPI实现上不同之处，就是ROPI可以全交给IDE，RWPI却有个重定向的寄存器R9，需要加载器完成。最终到了程序员这里，需要程序员设置合适的值。
2.给DLL静态变量分配的空间，请注意地址对齐，至少要4字节对齐，请使用MDK提供的关键字 __attribute__((aligned(8))) 来修饰，这里用4不用8，可能也行。











